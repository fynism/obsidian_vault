# A* search
**A* 搜索（A* Search）** 是一种用于图或网格中寻找最短路径的启发式搜索算法。它结合了：

- **Dijkstra 算法**（保证找到最短路径）的**完整性**
- **贪心最佳优先搜索**（使用启发式函数）的**效率**

A* 通过评估函数  
f(n)=g(n)+h(n)
来决定扩展哪个节点：

- g(n)：从起点到当前节点 nn 的实际代价（已知）
- h(n)：从节点 nn 到目标的**启发式估计代价**（需设计）
- f(n) 越小，节点越优先被探索

**曼哈顿距离:**
对两个点 (x1,y1)) 和 (x2,y2)，曼哈顿距离为：

∣x1−x2∣+∣y1−y2∣

![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20251227173720993.png)
一直扩展f(n)最小的分支，直到达到goal状态。

# Adversarial Search
你图中展示的是 **对抗搜索（Adversarial Search）**，也叫**博弈树搜索**，用于解决**两人零和博弈**问题（如井字棋、象棋、围棋等），其中一方赢则另一方输。

---

 **核心概念：**

- **两个玩家**：通常称为 **MAX** 和 **MIN**
    - **MAX**：希望最大化最终得分（或获胜）
    - **MIN**：希望最小化 MAX 的得分（或阻止其获胜）
- **轮流行动**：通常 MAX 先走，然后交替进行
- **目标**：MAX 要找到一个策略，确保无论 MIN 怎么走，自己都能赢（或获得最高分）

**Minimax Search**
> **“First of all, search all the state”**  
> → 算法首先要展开所有可能的后续状态（构建博弈树）。

> **“A value is estimated for MAX”**  
> → 每个叶节点（游戏结束或深度限制处）会评估一个数值（例如：赢=+1，输=-1，平局=0，或棋盘评分）。

> **“The higher the score, the better it is for MAX.”**  
> → 对 MAX 来说，分数越高越好（目标是最大化收益）。

> **“Max always choose operation with the bigger value”**  
> → 在 MAX 层（轮到你走），选择能带来最大得分的子节点。

> **“Min always choose the operation with the smaller value.”**  
> → 在 MIN 层（对手走），假设对手会选对你最不利的动作 → 选最小值。

  因此，最大值总是选择具有较大值的操作，而最小值总是选择具有较小值的操作。