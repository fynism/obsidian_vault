# 基础部分

![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103143911869.png)
**处理机状态：**
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103143833913.png)

# 进程调度 （Process scheduling）
是系统进行资源分配和调度的基本单位。
**进程的组成：**
<img src="https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103144954560.png" />

## **进程的状态：**
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103145305293.png)![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103150604764.png)
1. **创建 (New)**
    - 进程刚被创建，资源已分配，但尚未被调度执行。
    - **→ 就绪**：系统“许可”后进入就绪队列等待CPU。
2. **就绪 (Ready)**
    - 进程已准备好运行，只等CPU调度。
    - **→ 执行**：调度器选中该进程，分配CPU时间片。
    - **← 阻塞/执行**：从阻塞唤醒，或时间片用完后返回。
3. **执行 (Running)**
    - 进程正在CPU上运行。
    - **→ 阻塞**：因等待I/O、信号量、用户输入等事件而暂停。
    - **→ 就绪**：时间片用完，被调度器抢占，放回就绪队列。
    - **→ 终止**：任务完成或被强制结束，释放资源。
4. **阻塞 (Blocked / Waiting)**
    - 进程因等待某事件（如磁盘读取、网络响应）而暂停。
    - **→ 就绪**：所等事件发生后，重新进入就绪队列。
5. **终止 (Terminated)**
    - 进程结束，资源被回收。


## 相关概念
在调度算法中，相关核心概念如下（简洁版）：

- **周转时间（Turnaround Time）** = 完成时间 - 到达时间  
    （进程从进入系统到结束的总耗时）。
- **等待时间（Waiting Time）** = 开始执行时间 - 到达时间  
    （进程在就绪队列中等待 CPU 的时间）。
- **执行时间（Execution Time）** = 进程实际占用 CPU 的时间（题目中的 Burst Time）。
- **响应时间（Response Time）**（交互式系统） = 首次调度时间 - 到达时间  
    （用户感知的延迟，非抢占式下等同于等待时间）。
> 💡 公式关系：**周转时间 = 等待时间 + 执行时间**  
> 你的例子中：
> 
> - 若算 `开始时间 - 到达时间` → 是等待时间（如 P₂ 在 FCFS 中：开始时间 8.0 - 到达时间 0.4 = 7.6）。
> - 正确周转时间 = `完成时间 - 到达时间`（如 P₂：12.0 - 0.4 = 11.6）。

需要进一步解释可随时问。 😊

## 调度算法 scheduling algorithm

- **First-Come, First-Served Scheduling ，FCFS**
最简单的算法，就是先到先执行。
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103152110815.png)
若如图中所示顺序执行，那么平均等待时间是 (0+24+27)/2 = 17.相对来说较长。


- **Shortest-Job-First Scheduling** ， SJF
最短的任务最先开始，相比FCFS减少了平均等待时间。
*eg：*
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103152234282.png)

- **priority scheduling，优先级调度**
也很容易理解，优先级越高越先执行。有些用大的数字表示优先，有些用小的。无所谓。

- **round-Robin scheduling，轮转调度**
简单来说，每个程序都每次只能运行一个**时间片(time slice\)** 长度的时间。如果进程本身运行时间小于时间片长度，则继续执行下一个进程；如果进程本身运行时间长于时间片长度，则将其中断，并重新添加到ready就绪队列的尾部。
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103153243662.png)



# 同步
一些概念辨别：
1. **临界区（Critical Section）**
- 进程/线程中访问共享资源的**代码段**。
- **要求**：同一时刻只能有一个进程进入。
- **例子**：多个线程同时对 Java 中的 `static int counter` 执行 `counter++`，该操作就是临界区。

2. **互斥（Mutual Exclusion）**
- 保证临界区被独占访问的机制。
- **常用工具**：
    - **锁（Lock）**：Java 中的 `synchronized` 关键字、`ReentrantLock`。
    - **信号量（Semaphore）**：可控制同时访问资源的线程数量（如数据库连接池）。

 3. **死锁（Deadlock）**
- **定义**：两个或以上进程互相等待对方释放资源，导致全部阻塞。
- **必要条件**（四个同时满足）：
    1. 互斥条件
    2. 占有并等待
    3. 非抢占
    4. 循环等待
- **例子**：线程A持有锁1等待锁2，线程B持有锁2等待锁1。

 4. **同步 vs 通信**
- **同步**：关注**执行顺序**（如“B必须等A完成后再执行”）。
- **通信**：关注**数据传递**（如管道、消息队列）。
- **联系**：同步常用于保障通信的安全性（如生产者-消费者模型需同步+通信）。

![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103185011528.png)

***
## 死锁
### **死锁的定义**
当**两个或多个进程/线程**因竞争资源或相互等待对方持有的资源，导致**所有进程永久阻塞**，无法继续执行的状态。
**关键特征**：
- 无外部干预时，系统无法自行恢复；
- 资源未被释放，但被无效占用。

### 解决方法
![](https://cdn.jsdelivr.net/gh/fynism/Picogo@main/img/20260103195540845.png)

### **2. 死锁的四个必要条件（必须同时满足）**

| 条件        | 说明                         | 破坏方法举例              |
| --------- | -------------------------- | ------------------- |
| **互斥条件**  | 资源一次只能被一个进程独占使用（如打印机、锁）。   | 改用可共享资源（如只读文件）。     |
| **占有并等待** | 进程持有至少一个资源，同时等待其他进程占用的资源。  | 要求进程一次性申请所有所需资源。    |
| **非抢占条件** | 已分配的资源不能被强制剥夺，只能由持有者主动释放。  | 允许系统强制回收资源（如优先级调度）。 |
| **循环等待**  | 存在一个进程等待环：P1→P2→P3→...→P1。 | 按资源编号顺序申请（打破环路）。    |
